%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Сравнительный анализ методов абстрактной интерпретации и ограниченной 
проверки моделей}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе проводится сравнительный анализ абстрактной интерпретации и 
метода ограниченной проверки моделей. Рассаматривается классификация методов 
статического анализа. Проводится подробный обзор указанных методов статического 
анализа. На основе проведенного обзора проводится их сравнение. На основе 
проведенного анализа показывается актуальность проводимого исследования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Статический анализ ПО}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Статический анализ кода --- анализ программного обечпечения, производимый~(в 
отличие от динамического анализа) без реального выполнения анализируемой 
программы. Статические методы анализа ПО могут использовать для анализа не 
только исходный код программы, но и другие артефакты процесса разработки:
объектные файлы, промежуточные представления, спецификации и др. Одним из
главных недостатков методов статического анализа ПО является их вычислительная
сложность. Однако, развитие современной вычислительной техники позволяет
снизить влияние данного фактора, поэтому методы статического анализа в
настоящее время набирают популярность. 

Статические методы анализа ПО в основном разделяют на верефикацию и статический
анализ. Верификация --- это процесс математического доказательства соответствия 
программы ее исходным требованиям. С помощью верификации можно проверить и
доказать корректность разработанной программы по отношению к формально
описанной спецификации требований. Поэтому верификация в основном направлена
на поиск функциональных ошибок. Недостатком данного метода является
невозможность его полной автоматизации: для проведения анализа требуются ручные
подсказки о промежуточных и конечных целях доказательства и начальных условиях.
В группу методов верификации включают дедуктивную верификацию~\cite{
deductiveVerification} и метод проверки моделей~\cite{modelChecking}

Статический анализ --- это анализ программного обеспечения с целью выяснения 
каких-либо свойств программы. Он ориентирован, как правило, на поиск
нефункциональных ошибок. К основным достоинствам статического анализа
относится то, что он может быть полностью автоматическим и осуществляет 
поиск полностью без участия пользователя. Недостатками данной группы подходов
являются ложные обнаружения, высокие вычислительные затраты и практически полное
отсутствие возможности поиска нефункциональных ошибок~(частично данная проблема 
решается с помощью использвания контрактов~\cite{designByContract}). В данную
группу входит достаточно большое количество методов анализа ПО, как достаточно
простых~(сигнатурный анализ), так и сложных и ресурсоемких~(абстрактная 
интерпретация, метод ограниченной првоерки моделей, анализ типов).

Статический анализ ПО является активно развивающимся направлением в рамках
программной инженерии и все чаще и чаще используется для автоматического 
повышения качества ПО. Как уже говорилось ранее, абстрактная интерпретация и 
метод ограниченной проверки моделей являются наиболее распространенными 
методами СА и чаще всего используются как основа для коммерческих средств
повышения качества ПО. Рассмотрим эти методы более подробно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Метод ограниченной проверки моделей}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Метод ограниченной проверки моделей~(Bounded Model Checking, BMC) --- метод
статического анализа программ, изобретенный в 1999 году~\cite{symbolicModelChecking}.
BMC основан на методе проверки моделей: основная идея обоих методов заключается
в том, чтобы представить исходный код анализируемой программы в виде упрощенной
модели с конечным числом состояний~(в виде конченого автомата) и проверять 
выполнение необходимых требований~(спецификации) на полученной модели. Однако, 
эти методы кардинально отличаются по используемым инструментам.

Метод проверки моделей представляет исходную программу в виде структуры 
Крипке~\cite{kripkeModel}, автомата Бюхи~\cite{buchiAutomata} или другой 
подобной структуры. Спецификации системы кодируются в виде темпоральных 
формул ~\cite{temporalLogic}. Темпоральные формулы объединяются с моделью программы и полученная структура проверяется с помощью специального решателя. 
Если решателю удается доказать, что программа проверяемая структура корректна, 
значит анализируемая программа удовлетворяет требованиям. Иначе, решатель выдает
контрпример. Контрпример представляет собой последовательность состояний,
которые приводят программу к ошибке.

Главным преимуществом метода проверки моделей является полнота и точность --- 
если полученная модель программы удовлетворяет спецификациям, значит 
анализируемая программа тоже им удовлетворяет~(при условии, что модель и 
спецификации были получены корректно). Однако, данный метод обладает и рядом
существенных недостатков:
\begin{itemize}
\item в большинства программ невозможно построить модель автоматически,
практически всегда требуются подсказки со стороны разработчика;

\item размер пространства состояний получаемой модели растет экспоненциально в 
зависимости от количества переменных в программе. Таким образом, даже для
программ небольшого размера метод проверки моделей сталкивается с 
\textit{проблемой взрыва пространства состояний};

\item наиболее эффективные алгоритмы проверки моделей используют бинарные
решающие даиграммы~(binary descision diagram, BDD)~\cite{bdds} для 
представления логических формул. Эффективность BDD~(а, значит, и метода
ограниченной проверки моделей) сильно зависит от порядка переменных. Поэтому,
часто требуется вмешательство разработчика для определения <<правильного>>
порядка переменных;

\item последняя проблема вытекает из всех вышеописанных --- из-за высокой
сложности и размера получаемых моделей, метод ограниченной проверки моделей
имеет большие проблемы с производительностью.
\end{itemize}

Идея метода \textit{ограниченной} проверки моделей состоит в том, чтобы 
рассматривать только \textit{ограниченные} по длине пути в модели программы.
Благодаря ограничениям, которые накладываются на модель программы, задача
ограниченной проверки может быть эффективно сведена к \textit{задаче 
выполнимости булевых формул ~(satisfiability problem, SAT-problem)}. В 
последние годы было совершено много открытий в области решения задачи 
выполнимости будевых формул и было создано много эффективных инструментов для
решения данной задачи --- SAT- и SMT-решатели~\cite{sat, smt}. Поэтому, BMC использует SAT- и SMT-решатели для проверки соответствия модели спецификации.
Обобщенный алгоритм BMC выглядит следующим образом:
\begin{enumerate}
\item для анализируемой программы строится граф потока управления~(control
flow graph, CFG)~\cite{cfg} в форме статического однократного присваивания
~(static single assignment)~\cite{ssa};

\item все циклы в CFG раскручиваются на предопределенную глубину $k$;

\item полученная модель программы преобразуется в SMT-формулу $P$;

\item интересующее свойство программы преобразуется в SMT-формулу $Q$;

\item результирующая формула $P \land (\neq Q)$ проверяется на выполнимость с
помощью SMT-решателя;
	\begin{itemize}
	\item если формула выполнима --- SMT-решатель выдает контрпример, который 
	приводит к выполнению формулы~(нарушению свойства);
	\item если формула невыполнима --- свойство никогда не нарушается;
	\end{itemize}
\end{enumerate}

Таким образом, BMC решает проблему взрыва пространства состояний~(благодаря 
ограниченности модели) и использует SMT-решатели для решения задачи 
выполнимости формул. Поэтому, BMC --- эффективный метод анализа для очень 
большого класса реальных программ. Однако, он также обладает некоторыми 
недодстатками:
\begin{itemize}
\item для большого класса программ BMC является неполным анализом~(из-за 
ограниченности модели);

\item описанный ранее алгоритм BMC выполняется для \textit{каждого} 
проверяемого свойства программы в \textit{каждом} месте программы, в котором 
может произойти ошибка. Таким образом, несмотря на использование эффективных 
алгоритмов и инструментов, BMC остается достаточно ресурсоемким анализом;

\item сложности работы с SMT-решателями:
	\begin{itemize}
	\item некоторые неразрешимые в теории задачи очень быстро и эффективно 
	решаются SMT-решателями;
	\item наоборот, некоторые теоретически разрешимые задачи могут оказаться
	очень сложными для SMT-решателей;
	\item контрпримеры, выдаваемые SMT-решателями представлены в виде 
	SMT-формулы; для понимания результатов необходимо преобразовать эту формулу
	в термины оригинальной программы.
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Абстрактная интерпретация}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Резюме}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%