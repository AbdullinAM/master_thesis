%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Разработка алгоритма технологии объединения абстрактной интерпретации 
и метода ограниченной проверки моделей}
\label{chapter:algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В соответствии с поставленными задачами необходимо разработать технологию
объединения АИ и BMC. Технология состоих из нескольких этапов:
\begin{itemize}
\item интерпретация исходного кода программы;
\item проверка программы на наличие ошибок по результатам АИ;
\item интерпретация упрощенного представления программы;
\item проверка упрощенного представления программы на наличие ошибок по 
результатам АИ;
\end{itemize}

В данном разделе рассматриваются модели представления кода, для которых 
выполнялась разработка алгоритмов и описываются основные идеи, положенные в их
основу.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Модель представления кода исходной программы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Система LLVM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
LLVM (Low Level Virtual Machine) --- универсальная система анализа, 
трансформации и оптимизации программ, реализующая виртуальную машину с RISC-
подобными инструкциями. Центральным звеном LLVM является так называемое 
промежуточное представление (Intermediate Representation, IR), представляющее 
собой строго типизированный мета-ассемблер с бесконечным числом доступных для 
использования регистров.  Такая форма представления кода в LLVM (в виде IR) 
позволяет производить большое количество оптимизаций прямо над промежуточным 
представлением без необходимости учета особенностей исходного языка 
программирования, а строгая система типов делает код удобным для восприятия и 
позволяет производить преобразования, которые не представляется возможным 
выполнить при обычном трехадресном нетипизированном представлении кода.

Одной из самых важных частей LLVM является система проходов~\cite{llvmpass}. 
Проходы отвечают за трансформацию и оптимизацию промежуточного представления и 
объединяют результаты различных анализов для их использования в дальнейших 
преобразованиях.

Программы в LLVM представляются в виде набора отдельных модулей. Каждый модуль 
состоит из функций, глобальных переменных и дополнительных метаданных. Каждая 
функция, в свою очередь, состоит из базовых блоков. Каждый базовый блок имеет 
свою метку и состоит из последовательности инструкций, заканчивающейся 
инструкцией-терминатором, которая явно передает управление в другой блок или 
завершает выполнение текущей функции. Пример представления программы в системе 
LLVM приведен на рисунке \ref{image:llvmIR}.
\begin{figure}[h!]
\center{\includegraphics[width=\linewidth]{llvmIR}}
\caption{Пример представления функции в LLVM}
\label{image:llvmIR}
\end{figure}
    
Переменные исходной программы в LLVM представляются в виде регистров (память
на стеке) или в виде указателей на память (память на куче). Для регистров 
LLVM реализует статическое однократное присваивание (Static Single Assigment, 
SSA) --- форма представления кода, при которой любое значение присваивается 
только один раз. Любому регистру в LLVM можно присвоить значение только один 
раз --- при его объявлении. Для объединения потенциально различных значений 
одной и той же переменной исходной программы в SSA (то есть, и в LLVM) 
используются так называемые phi-функции, которые возвращают одно из значений в 
зависимости от того, какой блок передал управление текущему при выполнении 
программы.

Переменные в LLVM могут иметь следующие типы данных:
\begin{itemize}
\item простые типы:
    \begin{itemize}
    \item целые числа произвольной разрядности $i$. Эти числа представляются в 
    дополнительном коде, при этом различий между знаковыми и беззнаковыми 
    числами на уровне типов не делается: при необходимости с ними работают 
    разные инструкции;
    \item числа с плавающей точкой: half~(16-разрядные), float, double, quad~(
    128-разрядные) и некоторые платформозависимые типы~(например, x86\_f80);
    \item void --- пустое значение;
    \end{itemize}

\item производные типы:
    \begin{itemize}
    \item указатели;
    \item массивы;
    \item структуры~(обращение к полям структуры происходит не по имени, а по 
    номеру поля начиная с 0 в порядке их объявления);
    \item вектор --- специальный тип для упрощения SIMD-операций. Представляет 
    собой $2^n$ значений примитивного типа~(целого или с плавающей точкой);
    \item функции.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Представление программ в системе Borealis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Система Borealis использует LLVM IR для компиляции, трансформации и анализа 
программ. Для упрощения взаимодействия различных компонентов Borealis 
добавляет еще один уровень промежуточного представления в виде Predicate State 
API~(PS API). Упрощенное описание PS приведено на рисунке~\ref{image:
predicateStateDefinition}.

Инструкции LLVM преобразуются в предикаты (predicate), которые выполняют 
различные операции над термами (term). Термы используются для представления 
констант, переменных, бинарных операций. Каждый терм также может являться 
операндом другого терма или предиката. Каждый терм имеет тип, который 
сооттветствует типу переменной LLVM, которую он представляет. Предикаты 
соответствуют инструкциям LLVM.
    
Предикаты в системе имеют различные типы. Всего определено 6 типов предикатов:
\begin{itemize}
\item State --- обычные предикаты, соответствующие инструкциям LLVM;
\item Path --- предикаты пути соответствуют условиям перехода в различные 
ветки программы;
\item Requires --- предикаты, использующиеся для выражения предусловий функций;
\item Ensures --- предикаты, использующиеся для выражения постусловий функций;
\item Assert --- предикаты, проверяющиеся на истинность при анализе;
\item Assume --- предикаты, позволяющие задавать утверждения, которые всегда верны.
\end{itemize}

\begin{figure}
    \begin{grammar}
    \scriptsize
    <PredicateState> ::= PredicateStateChain head:<PredicateState> 
    tail:<PredicateState>
    \alt PredicateStateChoice choices:<ListOfPredicateStates>
    \alt BasicPredicateState data:<ListOfPredicates>

    <ListOfPredicateStates> ::= <PredicateState> <ListOfPredicateStates> | 
    <empty>

    <Predicate> ::= AllocaPredicate lhv:<Term> numElems:<Term> 
    origNumElems:<Term>
    \alt DefaultSwitchCasePredicate cond:<Term> cases:<ListOfTerms>
    \alt EqualityPredicate lhv:<Term> rhv:<Term>
    \alt GlobalsPredicate globals:<ListOfTerms>
    \alt InequalityPredicate lhv:<Term> rhv:<Term>
    \alt MallocPredicate lhv:<Term> numElems:<Term> origNumElems:<Term>
    \alt SeqDataPredicate base:<Term> data:<ListOfTerms>
    \alt SeqDataZeroPredicate base:<Term> size:UInt32
    \alt StorePredicate ptr:<Term> value:<Term>
    \alt WriteBoundPredicate ptr:<Term> boundValue:<Term>
    \alt WritePropertyPredicate propName:<Term> ptr:<Term> propValue:<Term>
    
    <Term> ::= ArgumentTerm idx:UInt32 kind:<ArgumentKind>
    \alt ArgumentCountTerm
    \alt AxiomTerm term:<Term> axiom:<Term>
    \alt BinaryTerm op:<BinaryOp> lhv:<Term> rhv:<Term>
    \alt BoundTerm term:<Term>
    \alt CastTerm term:<Term> signExtend:Bool
    \alt CmpTerm op:<CmpOp> lhv:<Term> rhv:<Term>
    \alt ConstTerm | FreeVarTerm
    \alt GepTerm base:<Term> shifts:<ListOfTerms> triviallyInbounds:Bool
    \alt LoadTerm ptr:<Term>
    \alt OpaqueBigIntConstantTerm value:String
    \alt OpaqueBoolConstantTerm value:Bool
    \alt OpaqueBuiltinTerm vname:String
    \alt OpaqueCallTerm func:<Term> args:<ListOfTerms>
    \alt OpaqueFloatingConstantTerm value:Double
    \alt OpaqueIndexingTerm value:<Term> index:<Term>
    \alt OpaqueIntConstantTerm value:SInt64 | OpaqueInvalidPtrTerm
    \alt OpaqueMemberAccessTerm value:<Term> property:String indirect:Bool
    \alt OpaqueNamedConstantTerm vname:String
    \alt OpaqueNullPtrTerm | OpaqueUndefTerm 
    \alt OpaqueStringConstantTerm value:String
    \alt OpaqueVarTerm vname:String
    \alt ReadPropertyTerm propName:<Term> ptr:<Term>
    \alt ReturnPtrTerm funcName:String
    \alt ReturnValueTerm funcName:String
    \alt SignTerm value:<Term>
    \alt TernaryTerm cond:<Term> tru:<Term> fls:<Term>
    \alt UnaryTerm op:<UnaryOp> value:<Term>
    \alt ValueTerm global:Bool
    \alt VarArgumentTerm index:UInt32

    <ListOfTerms> ::= <Term> <ListOfTerms> | <empty>

    <ArgumentKind> ::= ANY | STRING
    \end{grammar}
    
\caption{Определение предикатного состояния}
\label{image:predicateStateDefinition}
\end{figure}

Predicate state ставится в соответствие каждой функции программы. При этом, 
как показано на рисунке~\ref{image:predicateStateDefinition}, PS может 
состоять как из предикатов, так и из других predicate state. Вложенные PS 
обычно соответствуют базовым блокам LLVM IR. Predicate state бывает трех видов:
\begin{enumerate}
\item Basic PS --- PS, соответствующий базовым блокам LLVM.
\item Choice PS --- PS, который позволяет реализовывать ветвления. Каждой 
веткой choice PS может быть любой другой PS. Это позволяет представлять 
операторы множественного выбора и множественные ветвления. При этом стоит 
отметить, что в начале каждого PS, соответствующего какой-либо ветке, будет 
стоять предикат пути, определяющий условия входа в эту ветку.
\item Chain PS --- PS, позволяющий объединить несколько PS в единую 
последовательность. Используется для соединения Basic PS и Choice PS в единую 
структуру, аналогичную графу потока управления исходной программы.
\end{enumerate}

Предлагаемая технология объединения АИ и BMC будет описываться в темринах 
приведенных моделей кода. Передйдем к более детальному рассмотрению этапов
технологии.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Абстрактные домены для LLVM IR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Одним из главных этапов разработки технологии объединения АИ и BMC является
выбор абстрактных доменов для моделирования переменных LLVM и PS. Необходимо,
чтобы выбранные домены были нересурсоемкими, но обладали приемлемой точностью.
В данном разделе описываются абстрактные домены, выбранные для разработки 
технологии.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Целочисленный домен}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Одним из наиболее простых и эффективных доменов для представление целых чисел 
является интервальный домен. В этом домене каждая переменная $x$ представляется
как интервал $[a, b]$ всех значений, которые она может принимать. При этом 
минимальное значение домена $\bot$ соответствует пустому интервалу $[]$,
максимальное значение $\top = [-\infty, \infty]$. Операции объединения и
пересечения для интервального домена:
\begin{itemize}
\item $[a, b] \wedge [c, d] = [min(a, c), max(b, d)]$;
\item $[a, b] \vee [c, d] = [max(a, c), min(b, d)]$.
\end{itemize}

Арифметические операции над интервальным доменом достаточно просты:
\begin{itemize}
\item $[a, b] + [c, d] = [a + c, b + d]$;
\item $[a, b] - [c, d] = [a - d, b - c]$;
\item $[a, b] * [c, d] = [min(a * c, b * c, a * d, b * d), max(a * c, b * c,
a * d, b * d)]$;
\item $[a, b] / [c, d] = [min(a / c, b / c, a / d, b / d), max(a / c, b / c,
a / d, b / d)]$;
\end{itemize}

Как упоминалось ранее, целые числа в LLVM обладают фиксированной разрядностью, 
а арифметические и логические операции можно выполнять только для чисел с 
одинаковой разрядностью. Поэтому, границы интервала $a$ и $b$ тоже должны быть
целочисленными переменными с фиксированной разрядностью. Тогда, интервальный 
домен будет покрывать все числа в интервале $[0, 2^i - 1]$~(если считать, что
числа беззнаковые), где $i$ --- разрядность переменной. 

Однако, при использовании интервального домена для LLVM возникают некоторые 
проблемы. Более подробно рассмотреть их можно на примере функции из 
листинга~\ref{lst:funcC}. Представление данной функции в LLVM IR приведено в
листинге~\ref{lst:funcLLVM}.

\begin{lstlisting}[style=c, caption={Пример функции на языке С}, 
label=lst:funcC]
int foo(int x) {
    int y;
    if (x > 0) {
        y = x; // y1
    } else {
        y = x - 1; // y2
    }
    return y; // y3 = join(y1, y2)
}
\end{lstlisting}

\begin{lstlisting}[style=llvm, caption={Представление функции из 
    листинга~\ref{lst:funcC} в LLVM IR}, label=lst:funcLLVM]
define i32 @foo(i32 %x) #0 {
entry:
  %cmp = icmp sgt i32 %x, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:
  br label %if.end

if.else:
  %sub = add nsw i32 %x, 4294967295
  br label %if.end

if.end:
  %y.0 = phi i32 [ %x, %if.then ], [ %sub, %if.else ]
  ret i32 %y.0
}
\end{lstlisting}


Предположим, что $x = [0, \top]$, тогда $\%sub = [4294967295, \top]$, $\%y.0 = 
x \wedge \%sub = [0, \top] \wedge [4294967295, \top]$. Из-за того, что в LLVM целочисленные переменные не имеют знака, непонятно как интерпретировать данную
операцию объединения:
\begin{itemize}
\item если считать переменные беззнаковыми, то $\%y.0 = [0, \top]$;
\item если считать переменные знаковыми, то $\%y.0 = [4294967295, \top]$.
\end{itemize}

Для того, чтобы решить данную неоднозначность, каждую переменную необходимо
аппроксимировать двумя разными интервалами: один знаковый, другой беззнаковый.
Все операции, у которых не определен знак выполняются два раза: отдельно для
знаковых интервалов, отдельно для беззнаковых. Если у операции определен знак,
то операция выполняется только для соответствующих интервалов~(например, 
операция \texttt{udiv} использует только беззнаковые интервалы, 
\texttt{sdiv} --- только знаковые).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Домен для чисел с плавающей точкой}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Агрегатный домен}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Домен указателей}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Домен функций}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





