%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Сравнительный анализ методов абстрактной интерпретации и ограниченной 
проверки моделей}
\label{chapter:analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе проводится сравнительный анализ абстрактной интерпретации и 
метода ограниченной проверки моделей. Рассаматривается классификация методов 
статического анализа. Проводится подробный обзор указанных методов статического 
анализа. На основе проведенного обзора проводится их сравнение. На основе 
проведенного анализа показывается актуальность проводимого исследования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Статический анализ ПО}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Статический анализ кода --- анализ программного обечпечения, производимый~(в 
отличие от динамического анализа) без реального выполнения анализируемой 
программы. Статические методы анализа ПО могут использовать для анализа не 
только исходный код программы, но и другие артефакты процесса разработки:
объектные файлы, промежуточные представления, спецификации и др. Одним из
главных недостатков методов статического анализа ПО является их вычислительная
сложность. Однако, развитие современной вычислительной техники позволяет
снизить влияние данного фактора, поэтому методы статического анализа в
настоящее время набирают популярность. 

Статические методы анализа ПО в основном разделяют на верефикацию и статический
анализ. Верификация --- это процесс математического доказательства соответствия 
программы ее исходным требованиям. С помощью верификации можно проверить и
доказать корректность разработанной программы по отношению к формально
описанной спецификации требований. Поэтому верификация в основном направлена
на поиск функциональных ошибок. Недостатком данного метода является
невозможность его полной автоматизации: для проведения анализа требуются ручные
подсказки о промежуточных и конечных целях доказательства и начальных условиях.
В группу методов верификации включают дедуктивную верификацию~\cite{
deductiveVerification} и метод проверки моделей~\cite{modelChecking}

Статический анализ --- это анализ программного обеспечения с целью выяснения 
каких-либо свойств программы. Он ориентирован, как правило, на поиск
нефункциональных ошибок. К основным достоинствам статического анализа
относится то, что он может быть полностью автоматическим и осуществляет 
поиск полностью без участия пользователя. Недостатками данной группы подходов
являются ложные обнаружения, высокие вычислительные затраты и практически полное
отсутствие возможности поиска нефункциональных ошибок~(частично данная проблема 
решается с помощью использвания контрактов~\cite{designByContract}). В данную
группу входит достаточно большое количество методов анализа ПО, как достаточно
простых~(сигнатурный анализ), так и сложных и ресурсоемких~(абстрактная 
интерпретация, метод ограниченной првоерки моделей, анализ типов).

Статический анализ ПО является активно развивающимся направлением в рамках
программной инженерии и все чаще и чаще используется для автоматического 
повышения качества ПО. Как уже говорилось ранее, абстрактная интерпретация и 
метод ограниченной проверки моделей являются наиболее распространенными 
методами СА и чаще всего используются как основа для коммерческих средств
повышения качества ПО. Рассмотрим эти методы более подробно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Метод ограниченной проверки моделей}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Метод ограниченной проверки моделей~(Bounded Model Checking, BMC) --- метод
статического анализа программ, изобретенный в 1999 году~\cite{symbolicModelChecking}.
BMC основан на методе проверки моделей: основная идея обоих методов заключается
в том, чтобы представить исходный код анализируемой программы в виде упрощенной
модели с конечным числом состояний~(в виде конченого автомата) и проверять 
выполнение необходимых требований~(спецификации) на полученной модели. Однако, 
эти методы кардинально отличаются по используемым инструментам.

Метод проверки моделей представляет исходную программу в виде структуры 
Крипке~\cite{kripkeModel}, автомата Бюхи~\cite{buchiAutomata} или другой 
подобной структуры. Спецификации системы кодируются в виде темпоральных 
формул ~\cite{temporalLogic}. Темпоральные формулы объединяются с моделью программы и полученная структура проверяется с помощью специального решателя. 
Если решателю удается доказать, что программа проверяемая структура корректна, 
значит анализируемая программа удовлетворяет требованиям. Иначе, решатель выдает
контрпример. Контрпример представляет собой последовательность состояний,
которые приводят программу к ошибке.

Главным преимуществом метода проверки моделей является полнота и точность --- 
если полученная модель программы удовлетворяет спецификациям, значит 
анализируемая программа тоже им удовлетворяет~(при условии, что модель и 
спецификации были получены корректно). Однако, данный метод обладает и рядом
существенных недостатков:
\begin{itemize}
\item в большинства программ невозможно построить модель автоматически,
практически всегда требуются подсказки со стороны разработчика;

\item размер пространства состояний получаемой модели растет экспоненциально в 
зависимости от количества переменных в программе. Таким образом, даже для
программ небольшого размера метод проверки моделей сталкивается с 
\textit{проблемой взрыва пространства состояний};

\item наиболее эффективные алгоритмы проверки моделей используют бинарные
решающие даиграммы~(binary descision diagram, BDD)~\cite{bdds} для 
представления логических формул. Эффективность BDD~(а, значит, и метода
ограниченной проверки моделей) сильно зависит от порядка переменных. Поэтому,
часто требуется вмешательство разработчика для определения <<правильного>>
порядка переменных;

\item последняя проблема вытекает из всех вышеописанных --- из-за высокой
сложности и размера получаемых моделей, метод ограниченной проверки моделей
имеет большие проблемы с производительностью.
\end{itemize}

Идея метода \textit{ограниченной} проверки моделей состоит в том, чтобы 
рассматривать только \textit{ограниченные} по длине пути в модели программы.
Благодаря ограничениям, которые накладываются на модель программы, задача
ограниченной проверки может быть эффективно сведена к \textit{задаче 
выполнимости булевых формул ~(satisfiability problem, SAT-problem)}. В 
последние годы было совершено много открытий в области решения задачи 
выполнимости будевых формул и было создано много эффективных инструментов для
решения данной задачи --- SAT- и SMT-решатели~\cite{sat, smt}. Поэтому, BMC использует SAT- и SMT-решатели для проверки соответствия модели спецификации.
Обобщенный алгоритм BMC выглядит следующим образом:
\begin{enumerate}
\item для анализируемой программы строится граф потока управления~(control
flow graph, CFG)~\cite{cfg} в форме статического однократного присваивания
~(static single assignment)~\cite{ssa};

\item все циклы в CFG раскручиваются на предопределенную глубину $k$;

\item полученная модель программы преобразуется в SMT-формулу $P$;

\item интересующее свойство программы преобразуется в SMT-формулу $Q$;

\item результирующая формула $P \land (\neq Q)$ проверяется на выполнимость с
помощью SMT-решателя;
	\begin{itemize}
	\item если формула выполнима --- SMT-решатель выдает контрпример, который 
	приводит к выполнению формулы~(нарушению свойства);
	\item если формула невыполнима --- свойство никогда не нарушается;
	\end{itemize}
\end{enumerate}

Таким образом, BMC решает проблему взрыва пространства состояний~(благодаря 
ограниченности модели) и использует SMT-решатели для решения задачи 
выполнимости формул. Поэтому, BMC --- эффективный метод анализа для очень 
большого класса реальных программ. Однако, он также обладает некоторыми 
недодстатками:
\begin{itemize}
\item для большого класса программ BMC является неполным анализом~(из-за 
ограниченности модели);

\item описанный ранее алгоритм BMC выполняется для \textit{каждого} 
проверяемого свойства программы в \textit{каждом} месте программы, в котором 
может произойти ошибка. Таким образом, несмотря на использование эффективных 
алгоритмов и инструментов, BMC остается достаточно ресурсоемким анализом;

\item сложности работы с SMT-решателями:
	\begin{itemize}
	\item некоторые неразрешимые в теории задачи очень быстро и эффективно 
	решаются SMT-решателями;
	\item наоборот, некоторые теоретически разрешимые задачи могут оказаться
	очень сложными для SMT-решателей;
	\item контрпримеры, выдаваемые SMT-решателями представлены в виде 
	SMT-формулы; для понимания результатов необходимо преобразовать эту формулу
	в термины оригинальной программы.
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Абстрактная интерпретация}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Абстрактная интерпретация~(abstract interpretation, AI, АИ) --- метод 
статического анализа ПО, который был придуман Патриком и Радией Кузо в конце 1970-х годов~\cite{ai}. Основная идея данного подхода сводится к тому, чтобы 
определить специальную формальную семантику для программы, ассоциюрующую 
каждую точку исходной программы с множеством всех состояний программы в данной 
точке. Состояние программы в какой-либо точке ее исполнения --- это множество 
значений всех переменных программы, которые они могут принимать в данной точке 
ее исполнения. Согласно общепринятой терминологии, АИ переводит программу из 
\emph{конкретной семантики} в \emph{абстрактную семантику}, и проводит в ней 
\emph{приблизительное вычисление~(approximate computation)} множеста всех
состояний программы во всех точках ее исполнения. Приблизительное вычисление 
обозначает, что абстрактная семантика по определению неточна --- в ней могут 
присутствовать состояния, которых на самом деле невозможно достичь в 
конкретной семантике.

Математической основой абстрактной интерпретации является теория решеток~\cite{
lattice} и частично упорядоченных множеств~(partially ordered set, poset)
~\cite{poset}. Множество всех конкретных состояний программы $L$ и множество
всех абстрактных состояний программы $\hat{L}$ образуют собой частично 
упорядочнные множества. Функцию $\alpha: L \rightarrow \hat{L}$ называют 
функцией абстракции, $\gamma: \hat{L} \rightarrow L$ --- функций конкретизации.
Конкретная семантика --- это монотонная функция $f: L \rightarrow L$, 
абстрактная семантика --- монотонная функция $\hat{f}: \hat{L} \rightarrow \hat
{L}$. Абстрактную семантику $\hat{f}$ называют \emph{валидной}\footnote{далее
под абстрактной семантикой будет подразумеваться только валидная абстрактная
семантика}, если:
\begin{equation*}
\forall x \in L: (f \circ \gamma \circ \alpha)(x) \le (\gamma \circ \hat{f} 
\circ \alpha)(x)
\end{equation*}

Таким образом, абстрактная семантика является надмножеством конкретной 
сематники. Отсюда следует, что абстрактная интерпретация обладает $100\%$ полнотой.

Конкретное состояние хранит в себе конкретные значения всех переменных 
программы в данной точке ее исполнения. Абстрактное состояние отображает каждую
переменную в некоторый \emph{абстрактный домен}, описывающий множество всех
значений, которые может принимать переменная в данной точке. Абстрактный домен
должен представлять собой полную решетку~(иначе нарушается свойство полноты 
АИ), а значит должен обладать следующими свойствами:
\begin{itemize}
\item является частично упорядоченным множеством $D$;
\item имеет верхнаюю грань $\top, \forall x \in D: x \le \top$;
\item имеет нижнюю грань $\bot, \forall x \in D: \bot \le x$;
\item определена операция объединения
\begin{equation*}
\vee: \forall x, y \in D: x \le (x \vee y), y \le (x \vee y)
\end{equation*}
\item определена операция пересечения
\begin{equation*}
\wedge: \forall x, y \in D: (x \wedge y) \le x, (x \wedge y) \le y
\end{equation*}
\end{itemize}

Каждому типу данных исходной программы ставится в соответствие абстрактный
домен, описывающий этот тип данных. В терминах АИ принято, что если абстрактный
домен $\hat{x}$, описывающий переменную $x$, имеет значение $\bot$, значит 
переменная $x$ неинициализирована, а если $\hat{x} = \top$, то переменная $x$
может иметь любое значение, определенное для ее типа. Для абстрактного домена
определены абстрактные версии всех операторов, которые определены для того
типа переменных, которые он аппроксимирует. То есть можно сказать, что 
конкретная семантика --- это объединение всех конкретных операторов, 
определенных для всех типов данных, используемых в программе; соответственно,
абстрактная семантика --- объединение всех абстрактных операторов используемых 
абсрактных доменов.

Семантика программ обычно выражается в терминах \emph{точек неподвижности}
~(fixed points)~\cite{fixedPoint}. С точки зрения анализа необходимо найти
\emph{наименьшее} решение системы уравнений $x = f(x)$, где $x$ --- множество
переменных программы, $f$ --- семантика программы. То есть, необходимо найти
\emph{наименьшую точку неподвижности}~(least fixed point, lfp) функции $f$.
Существует несколько алгоритмов решения данной системы уравнений. Нативный
алгоритм поиска наименьшей точки неподвижности приведен на рисунке~\ref{image:
nativeLFP}. Однако, данный алгоритм никак не учитывает структуру анализируемой
программы.

\begin{figure}[h!]
\textbf{Вход:} $f$ --- функция переходов

\textbf{Выход:} $x$ --- наименьшая точка неподвижности

\begin{algorithmic} 
\State $x \gets (\bot, \bot, \ldots, \bot)$ 
\Repeat 
	\State $x \gets f(x)$ 
\Until $x = f(x)$ 
\end{algorithmic}

\caption{Нативный алгоритм поиска наименьшей точки неподвижности}
\label{image:nativeLFP}
\end{figure}

Если учесть, что получаемая система уравнения строится по графу потока 
управления программы, и зависимости между уравнениями в системе соответствуют
зависимостям между узлами CFG, можно получить более эффективный алгоритм поиска
наименьшей точки неподвижности~\ref{image:worklistLFP}. Данный алгоритм решает
систему уравнений по зависимостям: после обработки какой-либо переменной,
в очередь обработки добавляются все переменные, которые зависят от нее. Функция
$deps$ возвращает для переменной список переменных, зависящих от нее.

\begin{figure}[h!]
\textbf{Вход:} $f$ --- функция переходов

\textbf{Выход:} $x$ --- наименьшая точка неподвижности

\begin{algorithmic}
\State $(x_1, x_2, \ldots, x_n) \gets (\bot, \bot, \ldots, \bot)$ 
\State $WL \gets {v_1, v_2, \ldots, v_n}$ 
\While{$WL \neq \emptyset$} 
	\State ${v_i} \cup WL \gets WL$
	\State $y = f_i(x_1, x_2, \ldots, x_n)$ 
	\If{$x_i \neq y$} 
		\State $x_i \gets y$
		\State $WL \gets WL \cup deps(v_i)$
	\EndIf 
\EndWhile
\end{algorithmic}

\caption{Алгоритм поиска наименьшей точки неподвижности, использующий 
информацию о зависимостях между уравнениями}
\label{image:worklistLFP}
\end{figure}

Одним из главных преимуществ абстрактной интерпретации является ее 
гарантированная полнота~(относительно интересующих анализ свойств). То есть,
если АИ показала, что программа удовлетворяет какому-либо свойству, значит это
действительно так~(обратное, вообще говоря, не верно). Большинство современных
направлений в абстрактной интерпретации направлены на преодоление одного из ее
главных недостатков --- высокой ресурсоемкости. Моделирование семантики даже простейшей программы может потребовать очень большого количества памяти и 
процессорного времени, поэтому основной задачей в рамках АИ стал поиск баланса 
между приближенностью аппроксимации семантики и вычислительными ресурсами.
В основном данная проблема решается выбором необходимых абстрактных доменов:
можно разработать очень быстрый, но неточный анализ используя простейшие домены
и наоборот. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Резюме}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе была приведена классификация методов статического анализа 
программ. Были подробно рассмотрены два наиболее популярных и распространенных
метода статического анализа программ: метод ограниченной проверки моделей и
абстрактная интерпретация. На основе проведенного анализа методов можно 
выделить следующие тезисы:
\begin{itemize}
\item метод ограниченной проверки моделей:
	\begin{itemize}
	\item неполон по построению;
	\item может работать медленно в достаточно простых ситуациях~(из-за 
	особенностей работы SMT-решателей);
	\item обладает высокой вычислительной сложностью из-за большого количества
	вызовов SMT-решателя;
	\end{itemize}
\item абстрактная интерпретация:
	\begin{itemize}
	\item имеет $100\%$ полноту по построению;
	\item вычислительная сложность может <<настраиваться>> путем подбора
	соответствующих абстрактных доменов.
	\end{itemize}
\end{itemize}


Таким образом, можно использовать результаты работы АИ для <<отсеивания>> 
лишних вызовов SMT-решателя: если АИ показала, что в некоторой точке программы 
ошибки нет, значит ее гарантированно нет и можно не вызывать SMT-решатель для 
излишней проверки и <<сэкономить>> это время. Возможно, если сделать анализ АИ 
максимально быстрым, получится время работы всего анализа~(так как время 
работы АИ будет несоизмеримо мало с тем временем, которое будет сэкономлено).
Значит, проведение исследования по объединению метода ограниченной проверки
моделей и абстрактной интерпретации является актуальной задачей.