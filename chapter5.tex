%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Апробация разработанного прототипа и анализ полученных результатов}
\label{chapter:testing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе проводится оценка показателей разработанной технологии путем 
анализа результатов запуска прототипа на нескольких реальных программных 
проектах. Основным показателем эффективности прототипа является время его работы
в сравнении с работой системы Borealis без использования разработанной технологии.
Одним из косвенных показателей работы прототипа является количество проверок,
выполняемых SMT решателем.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Описание тестовых проектов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для апробации разработанного прототипа было выбрано несколько проектов с открытым
исходным кодом:
\begin{itemize}
\item библиотека \texttt{beanstalkd} --- простая и высокопроизводительная 
очередь, разработанная для уменьшения времени отклика при обращении к веб-
сервисам большого объема путем асинхронного запуска сложных задач;
\item библиотека \texttt{iputils} --- набор небольших утилит для работы с
сетью в Linux;
\item \texttt{clib} --- пакетный менеджер для языка C;
\item библиотека \texttt{mpc} --- легковесная библиотека парсер-комбинаторов;
\item библиотека \texttt{sds} --- простая и легковесная библиотека динамических
строк для языка C;
\item \texttt{git} — распределенная система контроля версий~(СКВ).
\end{itemize}

Данные проекты сильно отличаются друг от друга по размеру и структуре. 
\texttt{beanstalkd} является проектом среднего размера~($SLOC \approx 10k$), 
весь код является сильносвязным, его нельзя разбить на отдельные модули. Проект 
\texttt{iputils} также является средним~($SLOC \approx 19k$), однако он состоит 
из 11 маленьких подпроектов, которые практически не связаны друг с другом. 
\texttt{mpc} и \texttt{sds} --- это достаточно маленькие проекты~($SLOC \approx 
6.5k$ и $3.7k$ соответственно), которые компилируются в один файл. \texttt{clib}
--- это библиотека среднего размера~($SLOC \approx 18k$), которая также 
компилируется в один файл. \texttt{git} является большим программным
проектом~($SLOC \approx 340k$). Проект состоит из множества модулей~($\ge 50$), 
которые имеют большое количество общего кода.

\begin{table}
\caption{Тестовый набор проектов}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline 
\textbf{Проект} & \textbf{SLOC} & \textbf{Модульность}  \\ 
\hline 
beanstalkd & $10k$ & отсутствует \\ 
\hline 
iputils & $19k$ & явно выраженная \\ 
\hline 
git & $340k$ & явно выраженная \\ 
\hline 
clib & $18k$ & отсутствует \\ 
\hline 
mpc & $6.5k$ & отсутствует \\ 
\hline 
sds & $3.7k$ & отсутствует \\ 
\hline 
\end{tabular} 
\end{center}
\label{table:testProjects}
\end{table}

Характеристики тестовых проектов сведены в таблицу~\ref{table:testProjects}. 
Данный тестовый набор позволит проверить эффективность разработан­ной 
технологии как для малых, так и для больших проектов с разной степенью 
функциональной декомпозиции.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Схема работы прототипа}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Общая схема работы прототипа в тестовом режиме выглядит следующим образом:
\begin{itemize}
\item для целевого проекта из СКВ получается его последняя версия;
\item в файле конфигурации проекта в качестве используемого компилятора 
указывается Borealis;
\item производится сборка проекта;
\item производится анализ результатов работы прототипа.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Результаты тестирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Главной характеристикой, которая анализировалась при тестировании прототипа, 
является время работы системы на тестовых проектах в сравнении с временем
работы Borealis без модуля AI. Также, при апробации анализировалось количество 
проверок, которые выполнял SMT решатель. Запуск прототипа осуществлялся на 
компьютере с ОС Archlinux, процессором Intel Core i7-4790, объемом оперативной 
памяти 32~гб и твердотельным накопителем Intel SSDSC2BW24. В качестве SMT 
решателя в системе Borealis использовался решатель Boolector~\cite{boolector}. 
Результаты апробации прототипа приведены в 
таблицах~\ref{table:timeResults}~(временные показатели) 
и~\ref{table:checkResults}~(качественные показатели).
\begin{table}
\captionsetup{skip=5pt}
\caption{Временные показатели работы прототипа}
\centering
\begin{tabular}{|r|c|c|c|}
\hline
           & AI LLVM IR   & AI PS        & без AI    \\ \hline
beanstalkd & 8.935s       & 8.934s       & 8.969s    \\ \hline
clib       & 2m45.624s    & 44.746s      & 43.213s   \\ \hline
git        & 53m39.379s   & 45m16.965s   & 48m9.496s \\ \hline
iputils    & 52.555s      & 53.958s      & 56.239s   \\ \hline
mpc        & 22.379s      & 20.966s      & 21.067s   \\ \hline
sds        & 4.660s       & 5.365s       & 5.721s    \\ \hline
\end{tabular}
\label{table:timeResults}
\end{table}

Проанализировав результаты в таблице~\ref{table:timeResults}, можно сделать 
следующие выводы:
\begin{itemize}
\item AI LLVM IR для большинства проектов оказывается медленнее, чем
анализ без AI;
\item AI PS для большинства проектов оказывается быстрее, чем анализ
без AI;
\item прирост в скорости не превышает $6\%$~(а для большинства проектов прирост
еще меньше).
\end{itemize}

Можно заметить, что на проектах \texttt{clib} и \texttt{git} прототип с 
использованием интерпретации LLVM IR оказывается значительно медленнее, чем
Borealis без AI. Это объясняется следующими причинами. В проекте \texttt{clib}
создается большое количество глобальных массивов большого размера, которые
затем активно используются во всех функциях проекта. Каждый раз при обращении
к какому либо из массивов AI приходится проделать большое количество операций
объединения доменов, что сильно сказывается на производительности.

Как упоминалось ранее, проект \texttt{git} состоит из множества модулей, 
которые имеют очень большой объем общего кода. Поэтому, одни и те же функции
многократно анализируются в каждом модуле, что увеличивает время работы 
прототипа. Система Borealis умеет эффективно обрабатывать подобные случаи: она
сохраняет информацию об уже обработанных функциях для каждого проекта и не 
перезапускает анализ функции, если она уже проанализирована в другом модуле. 
Интерпретация на уровне PS тоже обрабатывает подобные ситуации, так как она
запускается только после того, как Borealis убедился, что конкретный PS 
необходимо проанализировать. При интерпретации LLVM IR невозможно исключить
из анализа какую-либо функцию из-за межпроцедурности анализа.

\begin{table}
\captionsetup{skip=5pt}
\caption{Количественные показатели работы прототипа}
\centering
\begin{tabular}{|r|c|c|c|c|c|c|}
\hline
            \multirow{2}{*}{}
           & \multicolumn{2}{c|}{AI LLVM IR} 
           & \multicolumn{2}{c|}{AI PS} 
           & \multicolumn{2}{c|}{без AI} \\ \cline{2-7}
           & SAT    & UNSAT   & SAT    & UNSAT   & SAT    & UNSAT   \\ \hline
beanstalkd & 356    & 252     & 360    & 161     & 360    & 247     \\ \hline
clib       & 599    & 258     & 960    & 234     & 960    & 449     \\ \hline
git        & 13177  & 10964   & 19665  & 9720    & 19665  & 15222   \\ \hline
iputils    & 519    & 1786    & 543    & 934     & 543    & 1819    \\ \hline
mpc        & 474    & 305     & 506    & 146     & 506    & 286     \\ \hline
sds        & 149    & 84      & 170    & 40      & 170    & 109     \\ \hline
\end{tabular}
\label{table:checkResults}
\end{table}

Таблица~\ref{table:checkResults} показывает, сколько вызовов SMT решателя было
произведено во время анализа. SAT и UNSAT --- это результат вызова 
SMT решателя~(формула выполнима и невыполнима соответственно). Если SMT решатель
вернул SAT в проверяемой инструкции программы присутствует ошибка, если 
UNSAT --- ошибки нет. Основной целью разработанной технологии является уменьшить
количество результатов UNSAT, то есть уменьшить количество проверок, которые не
сообщают об ошибке. Результаты показывают, что AI удается убрать достаточно 
большое количество UNSAT: при интерпретации PS количество UNSAT в среднем 
уменьшается на $46.67\%$~(разброс от $35\%$ до $63\%$). Однако, более интересны 
результаты интерпретации LLVM IR: убирается меньше UNSAT~(а в некоторых
случаях UNSAT становится больше), чем при AI PS, но при этом также уменьшается 
и количество результатов SAT. То есть AI убирает не только SMT вызовы, которые 
не сообщают об ошибках в программе, но и некоторые вызовы, которые находят 
ошибки. Это объясняется тем, что при интерпретации на уровне LLVM IR у анализа 
имеется больше информации, чем в PS~(сохраняются циклы, рекурсии, 
межпроцедурность и т.д.). Благодаря тому, что AI обладает полнотой, в подобных
ситуациях приоритет отдается результату, который выдает AI и сообщение об
ошибке не генерируется. Таким образом, интерпретация LLVM IR позволяет убирать
некоторые ложные срабатывания~(false positives) анализа.

Также интересны результаты анализа проектов \texttt{beanstalkd} и \texttt{mpc}:
суммарное количество проверок, выполняемых SMT решателем в режиме с 
интерпретацией LLVM, больше, чем в режиме без использования AI. Эта ситуация
возникает из-за особенностей работы системы Borealis. Дело в том, что в Borealis
идентифицирует ошибки в привязке к их местоположению в файле с исходным кодом на
языке С. В LLVM IR и PS могут присутствовать несколько инструкций и предикатов, 
которые на самом деле соответствуют одним и тем же строчкам кода на языке C.
Система Borealis обрабатывает подобные инструкции лениво: если в какой-то
строчке программы уже была обнаружена ошибка, он игнорирует все последующие 
проверки, привязанные к этой строчке. В некоторых ситуациях AI удается доказать,
что определенной инструкции $I$ ошибки нет. В таком случае Borealis игнорирует
проверку инструкции $I$, но из-за этого ему может потребоваться проверить 
некоторое количество других инструкций $I_0, ..., I_n$, привязанных к той же 
самой строчке кода~(если SMT решатель показывал, что в инструкции $I$ 
присутствует ошибка, то проверки инструкций $I_0, ..., I_n$ ранее 
игнорировались). Таким образом, общее количество проверок, выполняемых 
SMT решателем увеличивается.

Проанализировав все результаты апробации прототипа, можно сделать следующие 
выводы:
\begin{itemize}
\item на большинстве проектов абстрактная интерпретация практически не 
сказывается на времени работы анализа~(прирост менее $5\%$);
\item интерпретация LLVM IR значительно увеличивает время анализа некоторых
проектов из-за их высокой сложности;
\item интерпретация PS дает лучший прирост в скорости анализа~(убирается 
$\approx 50\%$ UNSAT), но интерпретация LLVM IR позволяет убирать ложные 
срабатывания~(false positives).
\end{itemize}

То есть, даже несмотря на то, что абстрактная интерпретация позволяет убрать
значительное количество лишних вызовов SMT решателя, она практически не
дает прироста в скорости анализа. Это объясняется тем, что даже несмотря на то, 
что решение выполнимости SMT формул --- это NP-полная задача, современные 
SMT решатели позволяют очень быстро и эффективно решать большое подмножество
подобных задач. Таким образом, разработанная технология лучше применима для
повышения производительности анализа, но получаемый прирост незначителен.
Также, разработанная технология применима для повышения точности анализа~(за 
счет возможности интерпретации LLVM IR убирать false positives).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Резюме}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе выполнена апробация прототипа, реализующего предложенную
технология объединения абстрактной интерпретации и метода ограниченной проверки
моделей. Апробация показала целесообразность применения предлагаемой 
технологии для повышения производительности анализа. Однако, апробация
также показала, что можно использовать интерпретацию LLVM IR для повышения
точности анализа: AI LLVM позволяет убирать ложные срабатывания.